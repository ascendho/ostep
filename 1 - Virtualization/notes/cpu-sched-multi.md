# cpu-sched-multi

## 核心结论
多处理器调度的核心是在**多CPU环境**下平衡三大目标：**扩展性**（支持更多CPU）、**缓存亲和性**（提升进程运行效率）、**负载均衡**（避免CPU空闲）。主流方案分为**单队列调度（SQMS）** 和**多队列调度（MQMS）**，前者简单易均衡但扩展性差，后者扩展性好但需解决负载不均，实际系统需根据场景取舍。

## 一、核心背景：多处理器特有的关键问题
多处理器调度的复杂度源于硬件架构和共享资源特性，需先解决三个基础问题：

### 1. 缓存一致性（Cache Coherence）
- 问题本质：多CPU共享主存，每个CPU有独立缓存，可能出现“缓存数据与主存/其他CPU缓存不一致”（如CPU1修改数据后未写回主存，CPU2读取到旧值）。
- 硬件解决方案：总线嗅探（Bus Snooping）——每个CPU缓存监听总线，当其他CPU修改自身缓存中的数据时，自动失效或更新本地缓存副本，保证内存视图一致。

### 2. 共享数据同步（Synchronization）
- 问题本质：多CPU并发访问共享数据（如队列、链表）时，可能出现数据竞争（如双删同一节点、重复返回同一值）。
- 软件解决方案：使用互斥锁（Mutex）等同步原语，保证共享数据的原子操作，避免并发错误。

### 3. 缓存亲和性（Cache Affinity）
- 核心概念：进程在某CPU运行时，其指令和数据会缓存到该CPU的缓存/TLB中；若后续仍在该CPU运行，可直接复用缓存数据，运行更快。
- 关键影响：频繁切换CPU会导致缓存失效，进程需重新加载数据，性能下降。调度器需优先让进程在原CPU运行。

## 二、核心调度方案：单队列 vs 多队列
### 1. 单队列调度（Single-Queue Multiprocessor Scheduling, SQMS）
#### （1）核心设计
- 所有就绪进程放入**一个全局队列**，每个CPU从队列中选取进程运行（如RR、MLFQ策略）。
- 本质：复用单CPU调度逻辑，仅需扩展“同时选N个进程”（N为CPU数）。

#### （2）优势
- 天然负载均衡：CPU从同一队列取进程，不会出现“部分CPU空闲、部分CPU繁忙”。
- 实现简单：无需额外设计队列管理或迁移逻辑。

#### （3）缺陷
- 扩展性差：全局队列需加锁保护（避免并发修改冲突），CPU数量越多，锁竞争越激烈，调度开销占比越高。
- 破坏缓存亲和性：进程可能被不同CPU交替调度，缓存数据频繁失效，性能下降。

#### （4）优化方向
- 增加亲和机制：尽量让进程在之前运行的CPU上继续执行，减少缓存失效。

### 2. 多队列调度（Multi-Queue Multiprocessor Scheduling, MQMS）
#### （1）核心设计
- 每个CPU对应**一个独立队列**，进程初始被分配到某队列（随机/负载均衡策略），各CPU独立调度自身队列中的进程。

#### （2）优势
- 扩展性极佳：无全局锁，CPU仅操作本地队列，锁竞争为0，支持更多CPU。
- 天然缓存亲和性：进程默认在同一CPU运行，缓存数据可复用，性能提升。

#### （3）核心缺陷：负载不均
- 问题本质：各队列进程数可能差异极大（如CPU0队列空、CPU1队列有多个长进程），导致部分CPU空闲，资源浪费。

#### （4）解决方案：进程迁移（Migration）
- 核心思路：将进程从繁忙CPU的队列迁移到空闲CPU的队列，平衡负载。
- 经典实现：工作窃取（Work Stealing）——
  1. 空闲CPU（源队列）定期检查其他CPU（目标队列）的队列长度；
  2. 若目标队列进程数显著多于源队列，“窃取”1个或多个进程到本地队列；
  3. 关键权衡：检查频率过高会增加开销，过低会导致负载不均。

## 三、实际系统实现：Linux多处理器调度器
Linux社区未统一多处理器调度方案，主流有三种调度器，体现不同设计取舍：

| 调度器       | 队列方案 | 核心特性                                                                 |
|--------------|----------|--------------------------------------------------------------------------|
| O(1)调度器   | 多队列   | 基于优先级（类似MLFQ），动态调整进程优先级，聚焦交互式作业响应性。         |
| 完全公平调度器（CFS） | 多队列 | 比例共享调度（类似步长调度），用vruntime衡量CPU占用，保证公平性与扩展性。 |
| BFS调度器    | 单队列   | 基于“最早合格虚拟截止时间优先（EEVDF）”，单队列设计简化逻辑，适合特定场景。 |

## 四、关键特性对比：SQMS vs MQMS
| 对比维度       | 单队列调度（SQMS）                | 多队列调度（MQMS）                |
|----------------|-----------------------------------|-----------------------------------|
| 扩展性         | 差（全局锁竞争）                  | 好（无全局锁）                    |
| 缓存亲和性     | 差（进程易切换CPU）               | 好（进程默认在本地CPU运行）        |
| 负载均衡       | 天然均衡（全局队列分配）          | 需手动迁移（如工作窃取）           |
| 实现复杂度     | 低（复用单CPU调度逻辑）            | 高（需设计迁移策略、队列管理）     |
| 适用场景       | 少CPU场景（如2-4核）              | 多CPU场景（如服务器、云主机）      |

## 五、核心总结
1. 多处理器调度的核心矛盾是“扩展性-缓存亲和性-负载均衡”的三角权衡，无完美方案；
2. SQMS适合简单场景，优势是负载均衡和实现简单，劣势是锁竞争和缓存失效；
3. MQMS是现代多CPU系统的主流选择，通过工作窃取等迁移策略解决负载不均，兼顾扩展性和缓存亲和性；
4. 缓存亲和性是多处理器调度的关键优化点，直接影响进程运行效率，需优先考虑。

## 六、作业方向（Simulation）
通过`multi.py`模拟器验证多处理器调度特性，核心任务：
1. 研究缓存大小对进程运行时间的影响（如工作集是否拟合缓存）；
2. 验证缓存亲和性：限制进程在固定CPU运行，对比自由调度的性能差异；
3. 探索超线性加速比：多CPU+缓存协同，是否能实现“N核CPU速度提升超N倍”；
4. 测试工作窃取策略：调整 peek 间隔（-P参数），观察负载均衡效果与调度开销的平衡；
5. 对比单队列与多队列调度：在不同CPU数量、进程数下，测试扩展性差异。

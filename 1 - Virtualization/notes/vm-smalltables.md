# vm-smalltables

## 核心结论
小型页表（Small Tables）是针对分页机制“页表过大、占用过多物理内存”的核心优化方案，核心思路是**仅存储有效虚拟页的映射关系**，而非完整虚拟地址空间的所有页表项。主流实现包括三类技术：多级页表（Multi-level Page Tables）、段页式混合（Hybrid Paging+Segmentation）、倒排页表（Inverted Page Tables），它们以轻微增加地址翻译延迟或硬件复杂度为代价，将页表占用内存从MB级降至KB级，完美适配32位/64位大地址空间场景。

## 一、核心问题（CRUX）

分页机制中，页表需为每个虚拟页分配一个页表项（PTE），导致大地址空间下页表体积庞大（32位地址空间+4KB页→4MB/进程，100个进程需400MB）。如何在不破坏分页“无外部碎片”优势的前提下，大幅减少页表的物理内存占用？如何平衡页表空间开销与地址翻译效率？

## 二、小型页表的三类核心实现
### 1. 多级页表（Multi-level Page Tables）：主流标准方案
#### 核心设计思想
将单级线性页表按“页大小”拆分成分层结构，形成“页目录→页表→物理页”的树状索引，仅为包含有效PTE的页表分配物理内存，无效页表部分直接省略。

#### 关键结构与地址翻译
以32位系统二级页表为例（页大小4KB）：
- 虚拟地址拆分：页目录索引（10位）+ 页表索引（10位）+ 页内偏移（12位）；
- 层级结构：
  1. 一级页目录（Page Directory）：存储页目录项（PDE），每个PDE指向二级页表的物理页框，含有效位（标记对应二级页表是否存在）；
  2. 二级页表（Page Table）：存储PTE，每个PTE指向目标物理页框；
- 翻译流程：
  1. 用页目录索引查询页目录，获取二级页表的物理基址（PDE有效时）；
  2. 用页表索引查询二级页表，获取物理页框号（PFN）；
  3. 拼接PFN与页内偏移，得到物理地址。

#### 空间节省效果
32位系统中，若进程仅使用12MB内存（3个二级页表）：
- 单级页表占用：4MB；
- 二级页表占用：1KB（页目录）+ 3×1KB（二级页表）= 4KB，空间节省99%以上。

#### 扩展：64位系统的多级页表
64位地址空间（实际使用48位）需四级页表：页全局目录（PGD）→页上级目录（PUD）→页中间目录（PMD）→页表（PT），通过更多层级进一步拆分索引，避免单级页表的天文级体积。

### 2. 段页式混合（Hybrid Paging + Segmentation）：针对性优化方案
#### 核心设计思想
结合分段的“逻辑分区”与分页的“固定大小块”，为每个逻辑段（代码段、堆、栈）单独分配一个页表，仅存储该段内有效虚拟页的映射，跳过段间无效地址区域的页表存储。

#### 关键结构与翻译流程
- 虚拟地址拆分：段号（SN）+ 段内VPN + 页内偏移；
- 核心组件：
  1. 段表：存储每个段的页表基址（base）和边界（bounds），标记段的有效性；
  2. 段内页表：仅存储该段内有效虚拟页的PTE；
- 翻译流程：
  1. 用段号查询段表，验证地址是否在段边界内（避免越界）；
  2. 用段内VPN查询该段的页表，获取PFN；
  3. 拼接PFN与偏移，得到物理地址。

#### 适用场景
适合地址空间“稀疏分布”的进程（如堆和栈占用小、中间区域大量未使用），可针对性节省无效区域的页表空间，但需避免分段带来的外部碎片问题。

### 3. 倒排页表（Inverted Page Tables）：极端大地址空间方案
#### 核心设计思想
颠覆传统“虚拟页→物理页”的正向映射，改为“物理页→虚拟页”的反向映射：仅为每个物理页框分配一个表项，记录占用该页框的进程ID（PID）和虚拟页号（VPN），而非为每个虚拟页分配PTE。

#### 关键结构与翻译流程
- 核心组件：
  1. 倒排页表：数组结构，索引为物理页框号（PFN），表项含PID、VPN、控制位；
  2. 哈希表：优化查找效率，输入（PID+VPN），输出倒排页表索引；
- 翻译流程：
  1. 用（PID+VPN）查询哈希表，快速定位倒排页表中的目标表项；
  2. 验证表项有效性，获取对应的PFN；
  3. 拼接PFN与偏移，得到物理地址。

#### 适用场景
64位超大大地址空间（如服务器、虚拟机），彻底解决“虚拟页数量远超物理页”导致的页表膨胀问题，但哈希冲突会增加少量查找延迟。

## 三、关键细节与协同机制
### 1. 地址翻译的延迟代价
- 多级页表：TLB未命中时，需访问多级表项（二级页表需2次内存访问，四级需4次），延迟高于单级页表；
- 倒排页表：依赖哈希表查找，最坏情况下需遍历冲突链，延迟略高；
- 缓解方案：TLB缓存高频映射，99%以上的翻译可通过TLB命中完成，掩盖多级查找的延迟。

### 2. 表项结构与控制位
- 页目录项（PDE）：含下一级页表的PFN、有效位、权限位（读/写/执行），64位系统中还含页大小标记（如PS位标记4MB大页）；
- 倒排页表项：含PID（区分不同进程的VPN）、VPN、有效位、脏位、引用位，与正向页表的PTE控制位功能一致。

### 3. 与TLB的协同关系
小型页表的核心是“省空间”，而TLB的核心是“提速度”，两者形成互补：
- 多级页表/倒排页表增加的翻译延迟，通过TLB的高命中率（98%+）抵消；
- TLB未命中时，才需执行多级查找或哈希查询，确保平均访问效率接近理想状态。

## 四、优势与权衡
### 1. 核心优势
- 空间开销极小：仅存储有效映射，页表占用从MB级降至KB级，支持大地址空间和多进程并发；
- 兼容分页核心优势：保留“无外部碎片”“稀疏地址空间支持”的特点，不牺牲分页的灵活性；
- 架构适配性强：多级页表适配32/64位系统，倒排页表适配超大大地址空间，覆盖各类场景。

### 2. 核心权衡
- 时间换空间：多级查找或哈希查询增加TLB未命中时的延迟；
- 硬件/软件复杂度提升：多级页表需硬件支持地址拆分，倒排页表需处理哈希冲突，OS需维护层级结构或哈希表；
- 局部性依赖：依赖程序局部性（少量页被高频访问），否则TLB未命中频繁，性能下降。

## 五、核心优化策略
### 1. 动态页表分配
仅在进程访问某段虚拟地址时，才创建对应的页目录项和页表，避免提前分配完整层级结构，进一步节省内存。

### 2. 哈希优化倒排页表
采用链地址法处理哈希冲突，或使用两级哈希表，减少冲突链长度，降低查找延迟。

### 3. 大页辅助优化
结合大页（2MB/1GB），减少页表层级（如4MB大页可跳过二级页表），同时减少TLB条目需求，提升命中率。

### 4. 页表缓存
将常用的页目录项/PTE缓存到L1/L2 Cache，减少TLB未命中时访问页表的延迟。

## 六、核心总结
1. 小型页表的本质：以“轻微延迟/复杂度”为代价，通过“仅存储有效映射”解决分页的页表膨胀问题，是现代OS的必备优化；
2. 方案选择逻辑：32位系统首选二级页表，64位系统用四级页表，超大大地址空间用倒排页表，稀疏地址空间用段页式混合；
3. 协同核心：与TLB深度配合，用TLB的高命中率掩盖小型页表的查找延迟，实现“空间省、速度快”的平衡；
4. 技术链条：分页（解决外部碎片）→ TLB（解决分页速度慢）→ 小型页表（解决分页空间大），共同构成现代内存虚拟化的核心技术栈。

## 七、作业方向（Simulation）
通过小型页表相关模拟器（如`paging-multilevel.py`、`inverted-pagetable.py`）验证核心特性，核心任务：
1. 多级页表空间测试：对比单级/二级/四级页表在不同进程内存使用率下的空间占用，绘制空间节省曲线；
2. 延迟对比：测试TLB命中/未命中时，不同页表方案的地址翻译延迟，量化TLB的加速效果；
3. 倒排页表冲突测试：改变进程数和虚拟页数量，观察哈希冲突对倒排页表查找延迟的影响；
4. 段页式适用性分析：测试稀疏地址空间与连续地址空间下，段页式与多级页表的性能差异；
5. 大页优化验证：测试大页对多级页表层级和TLB命中率的影响，分析大页的适用场景。

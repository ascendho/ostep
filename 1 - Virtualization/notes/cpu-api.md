# cpu-api

## 一、核心问题与定位
### 1. 核心问题（CRUX）
OS应提供怎样的进程创建与控制接口？如何设计才能兼顾**功能强大、易用性与高性能**？

### 2. 核心定位
本文档聚焦UNIX系统的进程操作API，核心是 `fork()`、`exec()`、`wait()` 三大系统调用的组合使用，以及基于这些接口的实用场景（如shell命令执行、IO重定向、管道），是理解OS进程管理实操的关键。

## 二、三大核心系统调用详解
### 1. `fork()`：创建进程（“复制”父进程）
`fork()` 是UNIX创建新进程的核心调用，特性独特且关键。

#### （1）核心功能
- 调用后创建一个**新进程（子进程）**，子进程是父进程的**几乎完全副本**。
- 子进程拥有独立的地址空间、寄存器、程序计数器（PC），与父进程共享代码段，但数据段、堆、栈独立复制（写时复制机制优化）。

#### （2）关键特性
- 返回值差异化：父进程返回子进程的PID（进程ID），子进程返回0（用于区分父子逻辑）；调用失败返回负数。
- 执行逻辑：子进程不从头执行`main()`，而是从`fork()`调用后继续执行（父进程已打印的内容不会重复）。
- 输出非确定性：父子进程的执行顺序由CPU调度器决定，可能父进程先运行，也可能子进程先运行（示例中两种输出顺序均可能出现）。

#### （3）示例代码（p1.c）
核心逻辑：父进程打印PID后调用`fork()`，父子进程分别打印自身PID，输出顺序不确定。

### 2. `wait()`：等待子进程结束（同步父子）
`wait()` 用于父进程等待子进程终止，解决`fork()`的非确定性问题。

#### （1）核心功能
- 父进程调用后会阻塞，直到任意一个子进程终止（或收到信号），才返回子进程的PID。
- 若父进程先运行，`wait()` 会让其暂停，直到子进程执行完毕，确保子进程输出先于父进程。

#### （2）示例代码（p2.c）
在p1.c基础上添加`wait(NULL)`，输出变为确定：子进程先打印，父进程后打印（返回子进程PID作为`wait()`的返回值）。

#### （3）补充说明
- 变体`waitpid()`：可指定等待的子进程（通过PID）、设置等待选项（如非阻塞），更灵活。
- 适用场景：需依赖子进程执行结果的场景（如子进程生成数据后父进程处理）。

### 3. `exec()`：替换进程映像（运行新程序）
`exec()` 家族调用（如`execvp()`）用于让进程运行全新程序，而非继续执行父进程代码。

#### （1）核心功能
- 加载指定可执行文件（如`wc`、`ls`），覆盖当前进程的代码段、静态数据，重新初始化堆、栈。
- 不创建新进程，仅替换当前进程的运行内容；成功调用后**不会返回**（后续代码不会执行），失败才返回-1。

#### （2）示例代码（p3.c）
子进程调用`execvp("wc", myargs)`，运行`wc p3.c`（统计文件行数、单词数、字节数），父进程等待子进程完成后打印信息。

#### （3）家族变体
Linux系统有6种变体（`execl()`、`execlp()`、`execle()`、`execv()`、`execvp()`、`execvpe()`），差异主要在参数传递方式（列表/数组）、是否搜索PATH环境变量、是否传递环境变量。

## 三、核心设计思想：`fork()` + `exec()` 分离的价值
UNIX将“创建进程”与“运行新程序”拆分为两个调用，而非合并为一个`spawn()`，是其强大灵活性的核心：
- 中间执行空间：子进程在`fork()`后、`exec()`前，可修改自身环境（如IO重定向、设置环境变量），再运行新程序。
- 典型应用：UNIX shell的实现（如bash、zsh）：
  1. shell打印提示符，等待用户输入命令（如`wc p3.c > newfile.txt`）；
  2. 调用`fork()`创建子进程；
  3. 子进程在`exec()`前执行IO重定向（关闭stdout，打开文件`newfile.txt`）；
  4. 子进程调用`exec()`运行命令（`wc`）；
  5. 父进程调用`wait()`等待子进程完成，再打印提示符。

### 实操案例：IO重定向（p4.c）
- 子进程逻辑：关闭标准输出（`STDOUT_FILENO`），打开文件`p4.output`，再调用`execvp("wc", myargs)`；
- 效果：`wc`的输出不会打印到屏幕，而是写入`p4.output`（文件描述符在`exec()`后保持有效）。

### 延伸应用：管道（Pipe）
通过`pipe()`系统调用创建内核管道（队列），将一个进程的stdout连接到另一个进程的stdin，实现命令链（如`grep -o foo file | wc -l`），本质也是利用`fork()`+`exec()`的分离设计。

## 四、进程控制与拓展内容
### 1. 信号（Signal）机制
- 核心作用：向进程发送外部事件指令（如终止、暂停、继续），是进程间通信的基础方式。
- 常用信号：`SIGINT`（Ctrl+C触发，终止进程）、`SIGTSTP`（Ctrl+Z触发，暂停进程）。
- 系统调用：`kill()` 发送信号，`signal()` 注册信号处理函数（进程收到信号后执行指定逻辑）。

### 2. 用户与权限控制
- 普通用户：仅能控制自己创建的进程（发送信号、终止等），避免恶意操作影响他人进程。
- 超级用户（root）：拥有最高权限，可控制所有进程（如终止系统级进程），需谨慎使用。

### 3. 实用工具
- `ps`：查看当前运行的进程列表（PID、状态等）。
- `top`：实时显示进程资源占用（CPU、内存）。
- `kill`/`killall`：向进程发送信号（如`kill -9 PID`强制终止进程）。

## 五、作业方向（理论+实操）
### 1. 模拟作业（fork.py）
- 核心目标：理解进程树的生成与演变，掌握`fork()`和`exit()`对进程关系的影响。
- 关键任务：预测不同随机种子、fork概率下的进程树结构；分析孤儿进程（父进程先退出）的处理逻辑。

### 2. 编程作业（实操API）
- 核心目标：巩固`fork()`/`exec()`/`wait()`的使用，理解进程间资源共享与隔离。
- 典型任务：
  1. 验证父子进程对变量的修改是否独立；
  2. 测试父子进程共享文件描述符的写入行为；
  3. 不使用`wait()`确保子进程先打印；
  4. 实现两个子进程的管道通信（`pipe()`+`fork()`）。

## 六、核心总结
1. UNIX进程API的核心是`fork()`（创建副本）、`wait()`（同步）、`exec()`（替换程序）的组合，分离设计赋予极强灵活性；
2. 核心价值：支持shell的IO重定向、管道等功能，无需修改被运行程序的代码；
3. 关键特性：`fork()`的复制特性、`exec()`的替换特性、`wait()`的同步特性，三者协同实现进程的创建与控制；
4. 拓展：信号机制用于进程间事件通知，用户权限确保系统安全，工具链提升进程管理效率。

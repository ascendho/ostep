# vm-mechanism

## 一、核心背景与核心问题

### 1. 核心背景
内存虚拟化延续CPU虚拟化的“有限直接执行（LDE）”核心思路：让程序直接在硬件上运行以保证效率，OS仅在关键节点介入以维持控制。地址转换是内存虚拟化的核心机制，通过硬件与OS协作，将程序的虚拟地址转换为物理地址，实现“私有地址空间”的 illusion。

### 2. 核心问题（Refined Crux）
- 如何高效实现内存虚拟化？
- 如何满足应用程序对地址空间的灵活使用需求？
- 如何控制应用程序的内存访问范围，确保进程间及OS与进程间的保护？
- 如何在实现以上目标的同时兼顾效率？

### 3. 初始简化假设
为简化初始实现，先设定三个假设（后续章节将逐步放松）：
- 用户地址空间需**连续**分配在物理内存中；
- 地址空间大小**小于物理内存**；
- 所有地址空间**大小相同**。

## 二、核心机制：地址转换与动态重定位（Base and Bounds）
### 1. 地址转换的本质
硬件在每次内存访问（指令获取、加载、存储）时，自动将程序生成的**虚拟地址**转换为实际的**物理地址**，实现程序地址空间与物理内存的解耦，且对程序完全透明。

### 2. 动态重定位（Base-and-Bounds）原理
动态重定位（又称基址-边界机制）是早期硬件支持的地址转换技术，核心依赖两个CPU寄存器：
- **基址寄存器（Base Register）**：存储程序地址空间在物理内存中的起始地址（即虚拟地址的偏移量）；
- **边界寄存器（Bounds/Limit Register）**：存储地址空间的大小，用于校验虚拟地址的合法性。

#### （1）地址转换公式
物理地址 = 虚拟地址 + 基址寄存器值  
示例：程序虚拟地址15KB，基址寄存器值32KB，则物理地址为47KB。

#### （2）边界检查与保护
每次地址转换前，硬件先校验虚拟地址：
- 若虚拟地址 ≥ 边界值 或 为负数，触发**异常**，OS终止违规进程；
- 仅校验通过的虚拟地址才会执行转换，确保程序仅能访问自身地址空间。

#### （3）静态重定位的对比（早期软件方案）
- 原理：加载程序时，由加载器（loader）改写程序中的所有地址，直接替换为物理地址；
- 缺点：无保护机制（程序可非法访问其他内存）、无法动态重定位地址空间，已被动态重定位替代。

### 3. 地址转换示例
假设进程地址空间大小16KB，被加载到物理内存32KB起始位置（基址=32KB，边界=16KB）：
| 虚拟地址 | 物理地址计算 | 结果 |
|----------|--------------|------|
| 0KB      | 0KB + 32KB   | 32KB（合法） |
| 128B     | 128B + 32KB  | 32896B（合法，对应指令fetch） |
| 15KB     | 15KB + 32KB  | 47KB（合法，对应变量x的访问） |
| 17KB     | 17KB ≥ 16KB  | 异常（越界） |

## 三、硬件支持要求
地址转换需硬件提供以下关键功能（确保效率与控制）：
| 硬件需求 | 核心作用 |
|----------|----------|
| 特权模式（内核态/用户态） | 防止用户进程执行特权操作（如修改基址/边界寄存器） |
| 基址-边界寄存器对 | 存储地址空间的物理起始位置与大小，每CPU配备一套 |
| 地址转换与边界检查电路 | 快速执行虚拟地址→物理地址转换，及合法性校验 |
| 修改基址-边界的特权指令 | 仅OS（内核态）可修改寄存器值，保证控制 |
| 异常处理程序注册指令 | OS通过特权指令设置异常处理逻辑（如越界处理） |
| 异常触发机制 | 虚拟地址越界或用户进程执行特权操作时，触发CPU异常 |

## 四、操作系统核心职责
OS需配合硬件完成内存虚拟化的管理，关键职责包括：
### 1. 内存管理
- 维护**空闲列表（Free List）**：跟踪物理内存中未使用的连续区域；
- 进程创建时：从空闲列表分配连续物理内存，用于存储进程地址空间；
- 进程终止时：回收该进程占用的物理内存，归还至空闲列表。

### 2. 基址-边界寄存器管理
- 进程首次运行前：将其地址空间的物理起始地址写入基址寄存器，地址空间大小写入边界寄存器；
- 上下文切换时：保存当前进程的基址-边界值至进程控制块（PCB），恢复待运行进程的寄存器值（因每CPU仅一套寄存器，需为不同进程切换配置）。

### 3. 异常处理
- 开机时注册异常处理程序：如“内存越界”“非法特权操作”的处理逻辑；
- 触发异常时：终止违规进程，回收其内存资源，清理相关数据结构（如进程表项）。

### 4. 地址空间重定位（可选）
进程未运行时，OS可将其地址空间从物理内存一个位置复制到另一个位置，更新PCB中的基址值即可。进程恢复运行时，通过新基址值实现地址转换，完全无感知地址空间迁移。

## 五、关键特性与局限性
### 1. 核心优势
- **高效性**：地址转换与边界检查由硬件完成，仅需简单加法与比较运算，不影响程序运行效率；
- **透明性**：程序无需修改任何代码，仍认为自身地址空间从0开始，完全感知不到地址转换过程；
- **保护性**：边界检查严格限制程序访问范围，防止进程非法访问其他进程或OS内存；
- **灵活性**：支持地址空间动态重定位，OS可按需调整进程在物理内存中的位置。

### 2. 局限性：内部碎片（Internal Fragmentation）
由于地址空间需连续分配，且按固定大小的“槽位”分配，进程实际使用的内存（如栈、堆）往往小于分配的连续物理内存，未使用的部分被浪费，这种浪费称为“内部碎片”。例如：进程地址空间16KB（栈+堆仅占用部分空间），分配32KB-48KB物理内存，中间未使用的区域即为内部碎片。

## 六、核心总结
1. 地址转换是内存虚拟化的核心机制，通过硬件（基址-边界寄存器、转换电路）与OS协作，实现虚拟地址到物理地址的动态转换；
2. 动态重定位（基址-边界）是最简单的地址转换技术，兼具高效、透明、保护特性，但存在内部碎片问题；
3. 核心逻辑延续“有限直接执行”：硬件负责高效的地址转换与边界检查，OS负责内存分配、寄存器管理、异常处理，平衡效率与控制；
4. 后续章节将放松初始假设，引入更复杂的机制（如分段、分页），解决内部碎片与地址空间灵活分配问题。

## 七、实践作业（Simulation）
通过`relocation.py`模拟器验证基址-边界机制的地址转换逻辑，核心任务包括：
1. 基于不同随机种子，判断虚拟地址是否合法，并计算合法地址的物理地址；
2. 确定边界寄存器的最小取值，确保所有生成的虚拟地址均合法；
3. 在给定边界值与物理内存大小的情况下，计算基址寄存器的最大允许值；
4. 分析边界寄存器值与随机生成虚拟地址合法性的比例关系，绘制图表。

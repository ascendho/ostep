# vm-freespace

## 核心结论
自由空间管理的核心是**处理可变大小内存块的分配与释放**，核心挑战是**外部碎片**（自由空间被拆分为离散小块，总空间足够但无法满足连续内存请求）。通过“拆分（Splitting）+ 合并（Coalescing）”两大关键机制，结合合适的分配策略（如首次适配、最佳适配）或进阶方法（分离链表、伙伴分配），可在时间开销、空间利用率之间权衡，适配不同工作负载。

## 一、核心问题（CRUX）
如何管理可变大小内存请求的自由空间？采用何种策略最小化碎片？如何平衡不同方案的时间（分配/释放速度）和空间（内存利用率）开销？

## 二、基础假设
文档基于以下简化假设展开讨论：
1. 接口：采用`malloc(size_t size)`（分配内存）和`free(void *ptr)`（释放内存），`free`无需传入大小参数；
2. 碎片焦点：主要关注**外部碎片**（离散小自由块导致无法满足连续请求），暂不重点讨论内部碎片（分配块大于请求大小的浪费）；
3. 内存不可重定位：分配给程序的内存块不能移动，无法通过紧凑（Compaction）消除碎片；
4. 管理范围：分配器管理一块连续的内存区域（堆），可通过系统调用扩展。

## 三、底层核心机制
自由空间管理的基础依赖四大底层机制，确保分配与释放的正确性和效率：

### 1. 拆分（Splitting）
- 核心逻辑：当自由块大小 > 请求大小（含头部开销）时，将自由块拆分为两部分：
  - 一部分用于满足当前分配请求（含头部）；
  - 剩余部分保留为新的自由块，留在自由链表中。
- 作用：避免大自由块浪费，充分利用内存。
- 示例：10字节自由块满足1字节请求时，拆分为1字节分配块（含头部）和9字节自由块。

### 2. 合并（Coalescing）
- 核心逻辑：释放内存块时，检查其相邻的前/后内存块是否为自由块，若相邻则合并为一个大自由块。
- 作用：避免释放后产生更多离散小自由块，缓解外部碎片。
- 反例：若不合并，释放中间块后会形成三个独立小自由块，无法满足大请求；合并后恢复为连续大自由块。

### 3. 头部跟踪（Header Tracking）
- 核心逻辑：分配块的内存地址前嵌入“头部（Header）”，存储关键信息：
  - 分配块大小（含头部自身）；
  - 魔术数（Magic Number）：校验内存完整性（避免非法free）。
- 作用：`free`时通过指针算术（`header = ptr - 1`）获取头部，自动计算释放块大小，无需用户传入。

### 4. 嵌入式自由链表（Embedded Free List）
- 核心逻辑：自由链表的节点（存储自由块地址、大小、下一个节点指针）直接存储在自由块内部，而非额外分配内存。
- 原因：分配器自身不能调用`malloc`，需利用自由块空闲空间存储链表结构。
- 示例：4KB堆初始化时，自由链表节点存储在堆起始位置，节点大小为4KB - 链表节点大小（如4088字节）。

## 四、基本分配策略
针对可变大小内存请求，主流基础策略各有权衡：

| 策略         | 核心逻辑                                  | 优点                                  | 缺点                                  |
|--------------|-------------------------------------------|---------------------------------------|---------------------------------------|
| 最佳适配（Best Fit） | 搜索所有自由块，选择“最小能满足请求”的块    | 减少内存浪费（剩余自由块最小）        | 搜索耗时（需遍历全链表）；易产生大量微小自由块 |
| 最差适配（Worst Fit） | 搜索所有自由块，选择“最大的”块分配          | 保留大自由块，避免小自由块堆积        | 搜索耗时；实际表现差，易导致碎片        |
| 首次适配（First Fit） | 从链表头部开始，选择“第一个能满足请求”的块  | 搜索速度快（无需遍历全链表）          | 易碎片化链表开头，后续搜索效率下降      |
| 下次适配（Next Fit） | 从上次搜索结束位置继续，而非从头开始        | 分散搜索压力，避免链表开头过度碎片化  | 碎片分布更均匀，但整体碎片率无明显优势  |

### 关键补充
- 链表排序影响策略效率：按地址排序（ADDRSORT）便于合并相邻自由块；按大小排序（SIZESORT）加速最佳适配搜索。

## 五、进阶管理方法
为解决基础策略的局限性，出现更高效的进阶方案：

### 1. 分离链表（Segregated Lists）
- 核心逻辑：按内存块大小分组，为常用大小（如8字节、16字节、64字节）单独维护自由链表，其余大小请求转发给通用分配器。
- 典型实现：Slab分配器（Solaris内核）：
  - 为内核常用对象（如锁、inode）创建专用缓存池；
  - 空闲对象预初始化，避免频繁初始化/销毁开销；
  - 缓存池不足时向通用分配器申请“ slab ”（页大小倍数），空闲时回收。
- 优点：分配/释放速度快，几乎无碎片；缺点：需平衡专用池与通用池的内存占比。

### 2. 伙伴分配（Buddy Allocation）
- 核心逻辑：内存块大小严格为2的幂（如8KB、16KB、32KB），分配与合并遵循“伙伴”规则：
  - 分配：递归拆分大块为两个“伙伴块”，直到块大小≥请求大小（含头部）；
  - 释放：检查“伙伴块”是否空闲，若空闲则合并为更大块，递归向上合并。
- 优点：合并逻辑简单（通过地址bit判断伙伴）；缺点：存在内部碎片（分配块为2的幂，可能大于请求大小）。

### 3. 其他优化
- 复杂数据结构：用平衡二叉树、伸展树替代链表，降低搜索耗时；
- 多核适配：Hoard、jemalloc等分配器，支持多线程并发分配，避免锁竞争。

## 六、OS相关扩展：堆扩展
当分配器的自由空间不足时，通过系统调用向OS申请更多内存：
- UNIX系统：`sbrk`（扩展堆顶）或`mmap`（映射匿名页）；
- OS动作：分配物理页，映射到进程地址空间，扩展堆大小，供分配器使用。

## 七、核心总结
1. 自由空间管理的核心矛盾：可变大小内存块导致外部碎片，需通过“拆分+合并”缓解；
2. 机制与策略的关系：拆分、合并是基础机制，分配策略（首次/最佳适配）决定块选择逻辑，进阶方法（分离链表、伙伴分配）通过结构优化提升效率；
3. 权衡原则：无“通用最佳方案”——追求空间利用率（最佳适配）则牺牲时间，追求速度（首次适配）则可能增加碎片；
4. 实际应用：依赖工作负载，如内核常用固定大小对象用Slab分配器，通用场景用首次适配+合并，多核场景用jemalloc。

## 八、作业方向（Simulation）
通过`malloc.py`模拟器验证自由空间管理特性，核心任务：
1. 对比不同策略（首次/最佳/最差适配）的分配结果，观察自由链表状态变化；
2. 分析链表排序方式（地址/大小排序）对策略效率的影响；
3. 验证合并（-C flag）对碎片的缓解效果，对比有无合并时的自由链表长度；
4. 调整分配比例（-P），观察接近100%或0%时的分配成功率；
5. 构造高碎片场景（-A flag），测试不同策略的抗碎片能力。

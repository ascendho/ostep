# cpu-sched

## 核心结论
本章围绕“如何设计调度策略”展开，通过逐步放松 workload 假设，引入**周转时间**和**响应时间**两大核心指标，介绍了四类经典调度算法（FIFO、SJF、STCF、RR），揭示了调度的核心权衡：**优化周转时间（短作业优先类算法）与优化响应时间（轮转类算法）不可兼得**，为后续复杂调度器（如MLFQ）奠定基础。

## 一、核心问题（CRUX）
如何构建调度策略的基础框架？关键假设是什么？哪些指标决定调度效果？早期计算机系统采用了哪些基础方法？

## 二、基础前提：Workload 假设
为简化初期讨论，先设定5个理想化假设（后续逐步放松）：
1. 所有作业运行时间相同；
2. 所有作业同时到达系统；
3. 作业一旦启动，必须运行至完成（非抢占式）；
4. 作业仅使用CPU，不执行I/O操作；
5. 作业的运行时间已知（调度器“全知”）。

## 三、核心调度指标
指标是衡量调度算法优劣的标准，本章聚焦两个核心指标：
### 1. 周转时间（Turnaround Time）
- 定义：作业完成时间 - 作业到达时间（\(T_{turnaround} = T_{completion} - T_{arrival}\)）；
- 场景：衡量批量作业的整体效率，优先优化短作业完成速度。
- 简化计算：若所有作业同时到达（\(T_{arrival}=0\)），则周转时间 = 完成时间。

### 2. 响应时间（Response Time）
- 定义：作业首次运行时间 - 作业到达时间（\(T_{response} = T_{firstrun} - T_{arrival}\)）；
- 场景：衡量交互式作业的用户体验（如键盘输入后多久有反馈），优先优化“首次响应速度”。

### 补充：公平性
通过 Jain 公平指数等衡量，指作业获得CPU时间的均衡程度。性能与公平性常存在冲突（如短作业优先可能饿死长作业）。

## 四、经典调度算法（按放松假设顺序）
### 1. 先进先出（FIFO/FCFS）：最简单的非抢占式算法
#### （1）核心逻辑
按作业到达顺序运行，一旦启动则运行至完成（非抢占式）。

#### （2）示例与性能
- 场景1：3个作业（A/B/C）同时到达，均运行10秒 → 完成时间分别为10/20/30秒，平均周转时间=20秒；
- 场景2：放松“作业运行时间相同”假设 → A（100秒）、B（10秒）、C（10秒）同时到达 → 完成时间100/110/120秒，平均周转时间=110秒。

#### （3）关键问题：护航效应（Convoy Effect）
长作业阻塞后续短作业，导致整体周转时间急剧上升（类似超市长队中有人推满购物车，后面少量物品的顾客被迫长时间等待）。

### 2. 短作业优先（SJF）：优化周转时间的非抢占式算法
#### （1）核心逻辑
优先运行**总运行时间最短**的作业（非抢占式），是理想假设下（已知作业长度、同时到达）优化周转时间的最优算法。

#### （2）示例与性能
- 场景：同FIFO的场景2（A=100秒，B=10秒，C=10秒） → 运行顺序B→C→A，完成时间10/20/120秒，平均周转时间=50秒，较FIFO提升54%。

#### （3）局限性
- 仅适用于“所有作业同时到达”的场景；
- 若短作业晚到，仍会被先到达的长作业阻塞（如A=100秒先运行，B/C=10秒10秒后到达，仍需等待A完成）；
- 非抢占式，无法应对动态到达的短作业。

### 3. 最短剩余时间优先（STCF/PSJF）：优化周转时间的抢占式算法
#### （1）核心逻辑
在SJF基础上增加**抢占机制**：任何新作业到达时，比较所有就绪作业的“剩余运行时间”，优先运行剩余时间最短的作业。

#### （2）示例与性能
- 场景：A=100秒（t=0到达），B/C=10秒（t=10到达） → 运行顺序：A（0-10秒）→ B（10-20秒）→ C（20-30秒）→ A（30-120秒）；
- 平均周转时间=50秒（A：120-0=120，B：20-10=10，C：30-10=20），彻底解决短作业晚到的阻塞问题。

#### （3）优势与局限
- 优势：已知作业长度时，是周转时间最优的调度算法；
- 局限：仍需“已知作业长度”的假设，且对响应时间优化不足（短作业虽优先，但后续作业可能长期等待首次运行）。

### 4. 轮转调度（RR）：优化响应时间的抢占式算法
#### （1）核心逻辑
- 按“时间片（Quantum）”划分CPU时间，作业运行一个时间片后，切换至下一个就绪作业（循环往复）；
- 时间片长度需为定时器中断周期的整数倍（如中断每10ms触发，时间片可设为10ms/20ms）。

#### （2）示例与性能
- 场景：3个作业（A/B/C）同时到达，均运行5秒，时间片=1秒 → 运行顺序：A(0-1)→B(1-2)→C(2-3)→A(3-4)→...，平均响应时间=1秒（A：0，B：1，C：2）；
- 对比SJF：SJF平均响应时间=5秒（A：0，B：5，C：10），RR响应时间提升80%。

#### （3）关键权衡：时间片长度
- 时间片越短：响应时间越好，但上下文切换开销（保存/恢复寄存器、缓存失效）越大；
- 时间片越长：上下文切换开销越小，但响应时间变差，逐渐接近FIFO；
- 核心原则：时间片需足够长，以“摊薄”上下文切换成本（如时间片=10ms，切换成本=1ms，仅10%时间浪费在切换）。

#### （4）局限性
- 周转时间极差：作业被频繁切换，完成时间大幅延长（如上述场景中，RR平均周转时间=14秒，SJF仅7秒）；
- 公平性与周转时间的冲突：RR均匀分配CPU，保证公平，但牺牲了短作业的快速完成。

## 五、放松假设：融入I/O操作
### 1. 核心问题
作业执行I/O时会阻塞（不使用CPU），若调度器仍等待其I/O完成，会浪费CPU资源。

### 2. 解决方案
将作业的“CPU burst（连续使用CPU的时间段）”视为独立“子作业”，按STCF/SJF调度：
- 作业发起I/O时，切换至其他就绪作业；
- I/O完成后，该作业的下一个CPU burst作为新作业加入就绪队列，重新参与调度。

### 3. 示例效果
- 场景：A（5个10ms CPU burst，每次burst后I/O 10ms）、B（1个50ms CPU burst）；
- 优化前：A运行至所有burst完成后再运行B，总耗时150ms；
- 优化后：A的burst与B的CPU使用重叠（A burst→B→A burst→B...），总耗时80ms，CPU利用率大幅提升。

## 六、最后一个难题：调度器并非“全知”
前面所有算法均依赖“已知作业长度”的假设，但实际系统中，OS无法预知作业运行时间。如何在无先验知识的情况下，兼顾周转时间与响应时间？这一问题将由下一章的“多级反馈队列（MLFQ）”解决。

## 七、四类算法核心对比
| 算法         | 类型       | 核心优势                  | 核心劣势                  | 优化指标       |
|--------------|------------|---------------------------|---------------------------|----------------|
| FIFO/FCFS    | 非抢占式   | 实现简单                  | 护航效应，周转时间差      | 无（基础算法） |
| SJF          | 非抢占式   | 已知作业长度时，周转时间最优 | 短作业晚到会被阻塞        | 周转时间       |
| STCF/PSJF    | 抢占式     | 动态响应短作业，周转时间最优 | 响应时间差，依赖作业长度已知 | 周转时间       |
| RR           | 抢占式     | 响应时间优，公平性好      | 周转时间差，切换开销大    | 响应时间       |

## 八、核心总结
1. 调度的本质是“权衡”：短作业优先类算法（SJF/STCF）优化周转时间，轮转算法（RR）优化响应时间，二者无法同时最优；
2. 抢占机制是关键：STCF通过抢占长作业，解决了短作业晚到的阻塞问题；RR通过抢占实现公平性与快速响应；
3. 实际系统需放松所有假设：需支持I/O、应对未知作业长度，后续MLFQ将通过“反馈学习”解决这一问题。

## 九、作业方向（Simulation）
通过 `scheduler.py` 模拟器验证算法特性，核心任务：
1. 计算3个200秒作业在SJF和FIFO调度下的响应时间与周转时间；
2. 改用100/200/300秒的异构作业，重复上述计算；
3. 加入RR调度（时间片=1），对比三类算法的指标差异；
4. 分析SJF与FIFO周转时间相同时的 workload 特征；
5. 推导SJF与RR响应时间相同时的 workload 与时间片条件；
6. 验证作业长度对SJF响应时间的影响趋势；
7. 推导RR调度下，N个作业的最坏响应时间公式（与时间片相关）。

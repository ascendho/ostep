# cpu-sched-mlfq

## 核心结论
MLFQ是一种“无先验知识”的调度算法，核心通过“多优先级队列+作业行为反馈”动态调整优先级，无需知道作业长度，即可同时优化**交互式作业的响应时间**和**短作业的周转时间**，兼顾长作业公平性，是现代操作系统（如Solaris、Windows NT）的主流调度器基础。

## 一、核心问题（CRUX）
如何在**无作业长度先验知识**的情况下，设计调度器：
1. 让短作业、交互式作业（依赖响应时间）快速执行；
2. 让长作业（CPU密集型）获得公平CPU时间，不被饿死；
3. 避免被恶意程序“欺骗调度”，抢占过多资源。

## 二、MLFQ基本原理
### 1. 核心设计思想
- 多队列：设置多个优先级递减的队列（如Q2最高、Q1中等、Q0最低）；
- 优先级反馈：根据作业“实际行为”调整优先级（如频繁放弃CPU→高优先级，持续占用CPU→低优先级）；
- 调度逻辑：高优先级队列作业优先执行，同优先级队列内按时间片轮转（RR）。

### 2. 初始规则（第一次尝试）
| 规则编号 | 规则内容 | 设计意图 |
|----------|----------|----------|
| 规则1    | 优先级A > 优先级B → A优先运行 | 保证交互式/短作业优先 |
| 规则2    | 优先级A = 优先级B → RR调度 | 同优先级作业公平共享 |
| 规则3    | 作业进入系统 → 放入最高优先级队列 | 默认假设是短/交互式作业 |
| 规则4a   | 作业用完当前队列时间片 → 优先级降低（下移队列） | 识别长作业，降低优先级 |
| 规则4b   | 作业主动放弃CPU（如I/O） → 保持当前优先级 | 不惩罚交互式/IO密集型作业 |

### 3. 初始规则的示例验证
- **长作业表现**：进入最高优先级Q2，用完1个时间片→Q1，再用完→Q0，之后一直在Q0轮转；
- **短作业表现**：长作业在Q0运行时，短作业进入Q2，优先执行并快速完成，近似SJF效果；
- **IO密集型作业表现**：每运行1ms就触发I/O，保持在Q2高优先级，响应迅速。

## 三、三次迭代优化：解决初始规则的缺陷
### 1. 第二次尝试：解决“长作业饥饿”问题
#### （1）缺陷
若系统中交互式/短作业过多，长作业会一直停留在低优先级队列，永远无法运行（饥饿）。

#### （2）新增规则（规则5）
- 规则5：每隔时间S，将所有作业移回最高优先级队列（优先级提升）。

#### （3）优化效果
- 长作业定期被提升到高优先级，获得CPU时间，避免饥饿；
- 若长作业转为交互式（如开始频繁I/O），提升后可被当作高优先级作业处理。

#### （4）关键参数
- 时间S：“巫毒常数”，需平衡：S过大→长作业饥饿；S过小→交互式作业响应变差，通常由管理员或机器学习自动调整。

### 2. 第三次尝试：解决“调度欺骗”问题
#### （1）缺陷
恶意程序可通过“快用完时间片时主动触发I/O”（如规则4b），保持高优先级，垄断CPU。

#### （2）修改规则4（替代原4a/4b）
- 规则4：作业在当前队列累计用完时间配额（无论是否主动放弃CPU）→ 优先级降低。

#### （3）优化效果
- 即使程序频繁触发I/O，累计用完配额后仍会下移队列，无法欺骗调度器。

### 3. 最终精炼规则
1. 高优先级作业优先运行；
2. 同优先级作业RR调度；
3. 新作业入最高优先级队列；
4. 作业累计用完当前队列配额→下移队列；
5. 定期（S）将所有作业移回最高优先级队列。

## 四、MLFQ的调优参数（实际系统配置）
MLFQ的性能依赖参数调优，核心参数包括：
1. **队列数量**： Solaris默认60个队列，优先级梯度更细腻；
2. **时间片大小**：高优先级队列→短时间片（如10ms，适配交互式作业）；低优先级队列→长时间片（如数百ms，减少长作业上下文切换开销）；
3. **优先级提升周期S**：Solaris默认约1秒，平衡饥饿与响应时间；
4. **配额设置**：每个队列的累计运行配额（如Q2配额=20ms，Q1=40ms），而非单时间片。

## 五、实际系统的MLFQ变种
- **Solaris TS调度类**：60个队列，时间片从20ms递增到数百ms，1秒优先级提升，支持管理员自定义参数表；
- **FreeBSD调度器**：用数学公式计算优先级，基于CPU使用量衰减（替代定期提升）；
- **Windows NT/后续版本**：简化版MLFQ，预留最高优先级给系统进程，支持用户通过`nice`命令调整优先级。

## 六、核心优势与局限性
### 1. 优势
- 无先验知识：无需知道作业长度，动态适应作业行为；
- 双目标优化：短作业/交互式作业响应快（近似SJF），长作业公平推进（无饥饿）；
- 实用性强：适配真实系统的混合 workload（交互式、短作业、长作业并存）。

### 2. 局限性
- 参数敏感：队列数、时间片、提升周期S等需反复调优，无通用最优值；
- 对IO密集型长作业友好性一般：若作业长期IO密集但总运行时间长，仍会被下移队列；
- 实现复杂：需跟踪作业在各队列的累计运行时间、处理优先级提升和队列迁移。

## 七、作业方向（Simulation）
通过`mlfq.py`模拟器验证MLFQ特性，核心任务：
1. 生成两作业两队列的简单场景，输出调度轨迹（关闭I/O，简化分析）；
2. 配置参数复现章节中的示例（如长作业饥饿、调度欺骗场景）；
3. 调整参数让MLFQ等效于RR调度（如单队列、无优先级提升）；
4. 构造欺骗 workload：利用旧规则4a/4b（-S flag），让一个作业抢占99% CPU；
5. 计算优先级提升周期S：最高队列时间片10ms，保证长作业至少获得5% CPU；
6. 测试I/O完成后队列插入位置（-I flag）对调度的影响。

## 八、核心总结
MLFQ的本质是“通过反馈学习作业行为”：将多队列的优先级机制与作业的实际运行表现结合，无需先验知识即可平衡响应时间与周转时间。其关键创新是“优先级动态调整”和“定期提升”，解决了无先验知识下的调度难题，成为工业界最成功的通用调度算法之一。

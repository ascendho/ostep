# cpu-intro

## 一、核心问题与虚拟化原理
### 1. 核心问题（CRUX）
如何用少量物理CPU，为用户提供“近乎无限个虚拟CPU”的错觉？让多个程序看似同时运行，提升系统易用性。

### 2. 核心解决方案：CPU虚拟化与时间共享
- **虚拟化本质**：OS通过“分时复用CPU”实现——运行一个进程→暂停→运行另一个，循环往复，营造多进程并发的错觉。
- **关键技术**：时间共享（Time Sharing），即资源按时间片分配给多个实体；对应空间共享（Space Sharing，如磁盘按空间划分），是OS共享资源的核心方式。
- **性能代价**：若进程过多，每个进程的CPU时间片被分割，运行速度会变慢。

### 3. OS的核心设计范式：机制与策略分离
- **机制（Mechanism）**：底层实现功能的方法/协议（如上下文切换，让OS能切换进程执行），回答“如何做”。
- **策略（Policy）**：上层决策算法（如调度策略，决定优先运行哪个进程），回答“选哪个”。
- **价值**：模块化设计，可独立修改策略（如切换调度算法）而不改动底层机制。

## 二、进程的本质：运行中的程序
进程是OS对“运行中程序”的抽象，其核心是**机器状态**——程序运行时需访问或修改的系统资源集合，包括三部分：
1. **内存**：进程的地址空间，存储代码、静态数据、堆（动态分配）、栈（局部变量/参数/返回地址）。
2. **寄存器**：包括程序计数器（PC，指向下一步执行的指令）、栈指针、通用寄存器等，直接影响指令执行。
3. **I/O信息**：当前打开的文件描述符（如UNIX默认的标准输入/输出/错误）等持久化存储相关信息。

## 三、进程API（核心接口）
所有现代OS都提供的进程操作接口，覆盖生命周期管理与控制：
- **创建（Create）**：启动新进程（如shell执行命令、双击应用图标）。
- **销毁（Destroy）**：强制终止进程（应对失控程序）。
- **等待（Wait）**：阻塞当前进程，直到目标进程终止。
- **杂项控制（Miscellaneous Control）**：暂停（Suspend）或恢复（Resume）进程。
- **状态查询（Status）**：获取进程运行时长、当前状态等信息。

## 四、进程创建的完整流程
OS将磁盘上的“静态程序”转化为“动态进程”，需完成以下步骤：
1. **加载代码与静态数据**：从磁盘读取程序指令和初始化变量，载入进程地址空间（早期OS“立即加载”，现代OS“延迟加载”，仅在需要时加载代码/数据）。
2. **初始化栈（Stack）**：分配内存用于存储局部变量、函数参数、返回地址，同时填充`main()`的参数（`argc`和`argv`数组）。
3. **分配堆（Heap）**：预留初始内存空间，供程序通过`malloc()`动态申请（后续可按需扩容）。
4. **I/O初始化**：UNIX系统中默认打开3个文件描述符（标准输入、输出、错误），方便程序读写终端。
5. **启动执行**：通过专用机制跳转到`main()`函数，将CPU控制权转移给新进程，程序正式运行。

## 五、进程状态与转换
进程在生命周期中会在三种核心状态间切换，状态变化由OS或进程自身操作触发：
### 1. 三种基本状态
- **运行（Running）**：进程正在CPU上执行指令。
- **就绪（Ready）**：进程已具备运行条件，但OS暂未分配CPU时间片。
- **阻塞（Blocked）**：进程因发起I/O（如磁盘读写、网络请求）等操作，需等待事件完成后才能继续运行。

### 2. 状态转换规则（如图4.2所示）
- 就绪 → 运行：OS调度（分配CPU时间片）。
- 运行 → 就绪：OS取消调度（收回CPU时间片，如时间片用完）。
- 运行 → 阻塞：进程发起I/O操作（如`read()`磁盘文件）。
- 阻塞 → 就绪：I/O事件完成（如磁盘数据读取完毕）。

### 3. 状态转换示例
| 场景                | 进程0状态变化                | 进程1状态变化                | 核心逻辑                     |
|---------------------|-----------------------------|-----------------------------|------------------------------|
| 纯CPU进程（无I/O）  | 运行→完成（退出）           | 就绪→运行→完成（退出）       | 先运行进程0，结束后运行进程1 |
| 带I/O的进程         | 运行→阻塞（发起I/O）→就绪（I/O完成）→运行→完成 | 就绪→运行→完成（退出）       | 进程0阻塞时，OS调度进程1运行，提升CPU利用率 |

## 六、核心数据结构：进程控制块（PCB）
OS通过数据结构跟踪所有进程状态，核心是**进程控制块（Process Control Block, PCB）**，也称“进程描述符”。

### 1. PCB核心字段（以xv6系统的`proc`结构为例）
- 基本信息：进程状态（`state`）、进程ID（`pid`）、父进程指针（`parent`）。
- 内存信息：进程内存起始地址（`mem`）、内存大小（`sz`）、内核栈地址（`kstack`）。
- 执行上下文：寄存器上下文（`context`，存储暂停时的寄存器值，用于恢复运行）、陷阱帧（`tf`）。
- I/O相关：打开的文件列表（`ofile`）、当前工作目录（`cwd`）。
- 其他：阻塞原因（`chan`）、是否被终止（`killed`）。

### 2. 进程列表（Process List）
OS维护的所有PCB集合，用于全局管理进程（如遍历就绪进程、查找阻塞进程、清理终止进程）。

### 3. 扩展状态
除核心三状态外，OS还会定义特殊状态：
- 初始状态（如xv6的`EMBRYO`）：进程创建中未就绪。
- 僵尸状态（`ZOMBIE`）：进程退出但未被父进程清理，保留退出码供父进程查询（父进程调用`wait()`后，OS清理该状态）。

## 七、核心总结
1. 进程是OS最基础的抽象，本质是“运行中的程序”，其状态由内存、寄存器、I/O信息共同构成。
2. CPU虚拟化的核心是“时间共享”，依赖上下文切换机制和调度策略，平衡并发与性能。
3. 进程生命周期的核心是“状态转换”，OS通过PCB跟踪进程信息，通过状态切换优化CPU利用率（如I/O阻塞时切换其他进程运行）。
4. 机制与策略分离是OS设计的关键原则，让系统更灵活、易扩展。

## 八、实践作业（Simulation）
通过`process-run.py`模拟器，验证进程状态转换与调度策略的影响，核心任务：
1. 计算CPU利用率（如纯CPU进程与I/O进程的资源占用差异）。
2. 分析调度触发时机（`SWITCH ON END` vs `SWITCH ON IO`）对进程完成时间的影响。
3. 验证I/O完成后的调度策略（`IO RUN LATER` vs `IO RUN IMMEDIATE`）对资源利用率的影响。

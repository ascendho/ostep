# threads-locks-usage

## 核心结论
为数据结构添加锁实现线程安全的核心逻辑是**“锁定临界区”**，但关键在于平衡“正确性”与“性能”：简单方案（全局大锁）易实现但扩展性差，优化方案（细粒度锁、分段锁、本地缓存）通过减少锁竞争提升并发度，却可能引入复杂度和精度权衡。文档通过计数器、链表、队列、哈希表四大典型结构，展示了“从简单到优化”的设计思路，核心原则是“先保证正确，再按需优化”，避免过早优化。

## 一、核心问题（CRUX）
如何为数据结构添加锁以保证线程安全？如何在保证正确性的前提下，设计锁策略以提升并发性能（让多线程访问时效率不显著下降）？

## 二、并发计数器（Concurrent Counters）
计数器是最简单的并发数据结构，核心操作是`increment`（自增）、`decrement`（自减）和`get`（读取值），其设计演进体现了“正确性→扩展性”的优化路径。

### 1. 基础方案：全局大锁（Simple But Not Scalable）
#### 设计逻辑
- 为计数器结构体添加一个全局互斥锁，所有操作（增、减、读）前加锁，操作后解锁，保证临界区互斥。
#### 代码核心结构
```c
typedef struct __counter_t {
    int value;
    pthread_mutex_t lock; // 全局锁
} counter_t;
void increment(counter_t *c) {
    Pthread_mutex_lock(&c->lock);
    c->value++; // 临界区：原子操作
    Pthread_mutex_unlock(&c->lock);
}
```
#### 优缺点
- 优点：实现简单，绝对正确，无数据竞争；
- 缺点：扩展性极差——多线程并发时，所有操作都竞争同一把锁，形成“串行瓶颈”，线程越多性能越差（如4线程执行时，耗时可能是单线程的数十倍）。

### 2. 优化方案：近似计数器（Approximate Counter，Scalable）
#### 设计思路
通过“本地缓存+全局汇总”减少锁竞争，核心是“将全局竞争分散为本地竞争”。
#### 核心结构
- 全局计数器（`global`）：存储汇总值，配全局锁（`glock`）；
- 本地计数器（`local[NUMCPUS]`）：每个CPU核心一个，配本地锁（`llock[NUMCPUS]`）；
- 阈值（`threshold`）：本地计数器累计到阈值后，才将值同步到全局。
#### 核心操作逻辑
1. **更新（update）**：
   - 线程根据ID映射到对应CPU的本地计数器，加本地锁后更新；
   - 若本地计数器值≥阈值，加全局锁，将本地值同步到全局，重置本地计数器。
2. **读取（get）**：
   - 加全局锁读取全局值（近似值，存在延迟）；
   - 若需精确值，需加所有本地锁和全局锁汇总（但牺牲扩展性）。
#### 优缺点
- 优点：扩展性极强——本地操作无跨CPU竞争，仅阈值触发时竞争全局锁，多线程性能接近单线程；
- 缺点：全局值是近似值（最大误差=CPU数量×阈值），需在“精度”和“性能”间权衡（阈值越大，性能越好但精度越差）。

## 三、并发链表（Concurrent Linked Lists）
链表的核心操作是`insert`（插入）和`lookup`（查找），重点解决“锁粒度”和“异常控制流”问题。

### 1. 基础方案：全局锁（Simple Concurrent List）
#### 设计逻辑
- 链表结构体添加全局锁，插入和查找操作全程加锁，保证链表节点修改（如`head`指针更新、节点`next`指针修改）的原子性。
#### 优化点：精简临界区
- 原方案：插入时先加锁再`malloc`（可能失败导致解锁繁琐）；
- 优化后：先`malloc`（假设`malloc`线程安全），仅在修改链表节点（`new->next = head`、`head = new`）时加锁，减少锁持有时间，降低竞争。
#### 代码核心优化
```c
int List_Insert(list_t *L, int key) {
    node_t *new = malloc(sizeof(node_t)); // 无锁阶段
    if (new == NULL) return -1;
    new->key = key;
    Pthread_mutex_lock(&L->lock); // 仅临界区加锁
    new->next = L->head;
    L->head = new;
    Pthread_mutex_unlock(&L->lock);
    return 0;
}
```

### 2. 优化方案：握手锁（Hand-over-hand Locking / Lock Coupling）
#### 设计逻辑
- 放弃全局锁，改为“每个节点加锁”：遍历链表时，先获取下一个节点的锁，再释放当前节点的锁（“握手”式传递锁），允许多个线程同时遍历链表的不同段。
#### 优缺点
- 优点：理论上并发度更高，支持多线程同时访问链表不同部分；
- 缺点：实际性能可能不如全局锁——每个节点的“加锁-解锁”开销累积，超过并发带来的收益；仅在链表极长、线程数多且访问分散时可能更优。

### 关键设计提示
- 避免异常控制流中的解锁遗漏：插入/查找时若遇到错误（如`malloc`失败、查找提前返回），需确保锁正确释放，建议通过“统一出口”（如查找时用`rv`变量记录结果，最后统一解锁）简化逻辑。

## 四、并发队列（Concurrent Queues）
队列的核心操作是`enqueue`（入队）和`dequeue`（出队），优化重点是“分离入队和出队的锁竞争”。

### 经典方案：Michael-Scott队列（Two Locks for Concurrency）
#### 设计亮点
- 双锁分离：队列头部（出队）和尾部（入队）各加一把锁，`enqueue`仅竞争尾锁，`dequeue`仅竞争头锁，两者可并发执行；
- 哑节点（Dummy Node）：初始化时添加一个空的哑节点，避免`head`和`tail`指针为空时的边界判断，简化锁逻辑。
#### 核心操作逻辑
1. **入队（Enqueue）**：加尾锁，将新节点接入尾节点`next`，更新`tail`指针，解锁；
2. **出队（Dequeue）**：加头锁，跳过哑节点取真实首节点，更新`head`为哑节点，释放旧哑节点，解锁。
#### 优点
- 并发性能优：入队和出队操作无锁竞争，支持高并发场景（如生产者-消费者模型）。

## 五、并发哈希表（Concurrent Hash Table）
哈希表通过“桶（Bucket）”分散数据，是并发性能最优的经典结构之一，核心优化是“分段锁”。

### 设计逻辑
- 哈希表由多个桶组成，每个桶是一个并发链表（带独立锁）；
- 插入/查找时，先通过哈希函数计算键对应的桶索引，仅对该桶加锁，不影响其他桶的操作。
#### 代码核心结构
```c
#define BUCKETS (101) // 桶数量（质数减少冲突）
typedef struct __hash_t {
    list_t lists[BUCKETS]; // 每个桶是一个并发链表
} hash_t;
int Hash_Insert(hash_t *H, int key) {
    return List_Insert(&H->lists[key % BUCKETS], key); // 仅锁定对应桶
}
```
#### 优点
- 极高扩展性：锁竞争被限制在单个桶内，多个线程访问不同桶时完全并行，性能接近单线程；
- 实现简单：基于已有并发链表，无需额外设计复杂锁逻辑。

## 六、关键设计原则与提示
### 1. 避免过早优化（Knuth’s Law）
- 优先使用全局大锁实现正确版本，仅当性能瓶颈出现时，再进行细粒度锁优化；
- 示例：Linux早期使用“大内核锁（BKL）”，仅当多核成为主流后，才替换为细粒度锁。

### 2. 锁策略与性能的权衡
- 全局锁：易实现、无bug，但扩展性差，适合低并发场景；
- 细粒度锁（节点锁、桶锁）：并发度高，但实现复杂，需避免死锁（如按固定顺序加锁）；
- 本地缓存（近似计数器）：性能优，但存在精度损失，适合对值精度要求不高的场景。

### 3. 控制流与锁的安全管理
- 避免在加锁后执行可能失败的操作（如`malloc`），若必须执行，需确保错误路径中正确解锁；
- 尽量统一锁的“加锁-解锁”路径，减少遗漏解锁的风险（如查找操作统一在循环结束后解锁）。

### 4. 并发度≠性能
- 过度细化锁（如链表的每个节点加锁）可能导致锁操作开销超过并发收益，需通过实测验证优化效果。

## 七、核心总结
1. 并发数据结构的设计逻辑：**“先正确，后高效”**——全局锁保证正确性，细粒度锁/分段锁/本地缓存提升并发度；
2. 典型结构的优化方向：
   - 计数器：全局锁→本地缓存+全局汇总（近似计数）；
   - 链表：全局锁→节点级握手锁；
   - 队列：全局锁→头尾双锁分离；
   - 哈希表：全局锁→桶级分段锁；
3. 关键权衡：正确性优先，性能优化需按需进行，避免为追求并发度引入不必要的复杂度。

## 八、作业方向（Code）
1. 实现基础并发计数器和近似计数器，对比不同线程数、不同阈值下的性能；
2. 实现握手锁链表，验证其在不同链表长度、线程数下的性能，与全局锁链表对比；
3. 选择自定义数据结构（如B树），先实现全局锁版本，再设计细粒度锁优化版本，对比性能；
4. 研究`gettimeofday()`等计时器的精度，用于并发程序的性能测量。

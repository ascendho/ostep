# threads-events

## 核心结论
事件驱动并发是线程之外的重要并发模型，核心是**“事件循环+非阻塞I/O+异步处理”**：通过主动监听事件（如I/O就绪、信号）并顺序处理，实现并发控制。其核心优势是无锁（避免线程死锁、原子性问题）、调度完全由应用掌控；核心挑战是需处理异步I/O、手动管理状态（复杂度高），且多核场景下仍需同步。适用于GUI应用、网络服务器（如node.js）等I/O密集型场景，与线程模型形成“简单性”和“控制力”的权衡。

## 一、核心问题（CRUX）
如何不依赖线程构建并发服务器，既能保留对调度的完全控制，又能规避线程相关的死锁、竞态条件等bug？

## 二、核心思想：事件循环（Event Loop）
### 2.1 基本逻辑
事件驱动程序的核心是一个无限循环，持续等待并处理事件，流程极简：
```
while (1) {
    events = 获取就绪事件（如I/O、信号）;
    for (每个事件e) {
        调用事件处理器（event handler）处理e;
    }
}
```
- 事件：触发程序动作的事件源，如“网络数据到达”“文件I/O完成”“信号触发”；
- 事件处理器：处理特定事件的代码片段，执行时独占CPU（单线程模型），无并发冲突；
- 调度控制：应用自主决定事件处理顺序，无需依赖OS线程调度，这是事件驱动的核心优势。

### 2.2 关键前提：非阻塞接口
事件循环必须基于**非阻塞I/O接口**：
- 阻塞接口（如普通`read()`）会暂停整个程序，导致事件循环停滞；
- 非阻塞接口（如异步I/O）仅启动操作并立即返回，操作在后台完成后通过“事件”通知程序，确保事件循环持续运行。

## 三、关键API：事件监听（select()/poll()）
### 3.1 核心功能
`select()`和`poll()`是OS提供的核心API，用于监听多个文件描述符（fd）的I/O状态，解决“如何获取就绪事件”的问题：
- 监听类型：可读（如网络数据到达）、可写（如发送缓冲区空闲）、异常条件；
- 核心作用：批量检查多个fd的状态，避免对每个fd轮询（浪费CPU），仅返回就绪的fd。

### 3.2 select() API详解
#### 函数原型（Mac/Linux）
```c
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);
```
#### 关键参数与操作
- `nfds`：需检查的最大fd+1（fd从0开始）；
- `fd_set`：文件描述符集合，通过宏操作（`FD_ZERO`清空、`FD_SET`添加、`FD_ISSET`检查）管理；
- `timeout`：超时时间（NULL=无限阻塞，0=立即返回，非NULL=指定超时）；
- 返回值：就绪的fd总数。

#### 简单使用示例
```c
// 初始化fd集合（监听minFD到maxFD的所有fd）
fd_set readFDs;
FD_ZERO(&readFDs);
for (fd = minFD; fd < maxFD; fd++) {
    FD_SET(fd, &readFDs);
}
// 监听可读事件（阻塞直到有fd就绪）
int rc = select(maxFD+1, &readFDs, NULL, NULL, NULL);
// 处理就绪fd
for (fd = minFD; fd < maxFD; fd++) {
    if (FD_ISSET(fd, &readFDs)) {
        processFD(fd); // 处理该fd的可读事件
    }
}
```

### 3.3 select()与poll()的关系
- 功能一致：均用于监听多个fd的I/O状态；
- 差异：`select()`受fd数量限制（默认1024），`poll()`无此限制，接口更灵活；
- 本质：均是“水平触发”的I/O多路复用机制，是事件驱动的基础。

## 四、核心优势：无锁设计，规避线程bug
### 4.1 无锁的原因
事件驱动模型在单线程下运行，同一时间仅处理一个事件：
- 无临界区冲突：无需锁保护共享资源；
- 无线程相关bug：避免死锁、原子性违反、顺序违反等线程并发问题；
- 简化编程：无需关注锁的获取/释放、线程同步等复杂逻辑。

### 4.2 调度可控
应用自主决定事件处理顺序，而非依赖OS调度：
- 可优先处理高优先级事件（如紧急信号、关键客户端请求）；
- 避免OS调度的“非最优”决策（如线程频繁切换、资源竞争导致的性能下降）。

## 五、核心问题与解决方案
### 5.1 问题1：阻塞系统调用（如磁盘I/O）
#### 矛盾
事件循环是单线程的，若事件处理器调用阻塞系统调用（如普通`open()`/`read()`），会导致整个事件循环停滞，服务器无法响应其他事件。

#### 解决方案：异步I/O（Asynchronous I/O）
OS提供异步I/O接口，允许程序启动I/O操作后立即返回，I/O完成后通过事件通知：
- 核心结构（以Mac为例）：`struct aiocb`（AIO控制块），存储I/O参数（文件fd、偏移量、缓冲区、长度）；
- 核心API：
  - `aio_read(struct aiocb *aiocbp)`：启动异步读操作，立即返回；
  - `aio_error(const struct aiocb *aiocbp)`：检查I/O是否完成（返回0=完成，`EINPROGRESS`=未完成）；
- 通知机制：
  - 轮询：通过`aio_error()`定期检查（简单但低效）；
  - 信号：I/O完成时OS发送信号，触发信号处理器（避免轮询，高效）。

### 5.2 问题2：状态管理（手动栈管理）
#### 矛盾
线程模型中，函数调用状态（局部变量、返回地址）保存在线程栈中，阻塞后恢复时自动复用；而事件驱动模型中，异步I/O会中断处理流程，需手动保存状态，供I/O完成后继续处理。

#### 解决方案：Continuation（延续）
- 核心思想：将“未完成的处理逻辑+所需状态”封装在数据结构中（如哈希表、结构体）；
- 示例：读取文件后写入网络 socket：
  1. 启动异步读文件时，将socket fd、文件fd、缓冲区等状态存入`continuation`结构；
  2. 读I/O完成后，事件处理器通过文件fd查找`continuation`，获取socket fd，继续执行写入操作。

## 六、其他关键难点
### 6.1 多核适配
单线程事件驱动无法利用多核CPU，若启动多个事件循环（每个CPU一个），则需同步共享资源，回到线程模型的锁问题，失去无锁优势。

### 6.2 隐式阻塞
即使避免了显式阻塞调用，仍可能因“隐式阻塞”导致事件循环停滞：
- 示例：事件处理器执行时触发页错误（内存页不在物理内存），OS会阻塞进程直到页加载完成；
- 影响：难以避免，可能导致服务器响应延迟。

### 6.3 代码维护复杂度
- 异步逻辑拆分：一个完整流程需拆分为多个事件处理器（如“启动I/O”“处理I/O完成”），代码连贯性差；
- API语义变化风险：若依赖的接口从非阻塞变为阻塞，会直接导致事件循环卡死，需持续监控API语义。

### 6.4 I/O接口不统一
网络I/O可通过`select()`监听，但磁盘异步I/O需使用`aio_*`系列API，无统一接口，增加编程复杂度。

## 七、与线程模型的对比
| 特性                | 事件驱动并发                | 线程并发                  |
|---------------------|-----------------------------|---------------------------|
| 调度控制            | 应用自主控制                | OS调度，应用无控制权      |
| 同步需求            | 单线程无锁，多核需同步      | 需锁/条件变量同步         |
| 编程复杂度          | 高（异步I/O+状态管理）      | 低（线性代码+栈保存状态） |
| 适用场景            | I/O密集型（GUI、网络服务器） | CPU密集型+I/O密集型       |
| 性能（无竞争）      | 高（无线程切换开销）        | 中（线程切换开销）        |

## 八、总结
1. 事件驱动并发的核心是“事件循环+非阻塞I/O+异步处理”，优势是无锁、调度可控，劣势是复杂度高；
2. 关键技术：`select()`/`poll()`（事件监听）、异步I/O（避免阻塞）、Continuation（状态管理）；
3. 适用场景：I/O密集、对调度有严格要求的系统（如node.js服务器、GUI应用）；
4. 权衡：放弃线程模型的简单性，换取对并发的完全控制，是“控制”与“复杂度”的取舍。

## 九、作业方向（Code）
1. 实现简单TCP服务器：单请求处理（返回当前时间）；
2. 集成`select()`：支持多连接并发，监听并处理多个客户端请求；
3. 扩展文件服务：客户端请求读取文件，服务器用同步I/O返回文件内容；
4. 替换为异步I/O：用`aio_*`接口重构文件读取逻辑，体验异步编程复杂度；
5. 添加信号处理：实现信号触发的缓存清理功能；
6. 性能对比实验：对比事件驱动与线程模型的吞吐量、延迟，分析实现复杂度。
